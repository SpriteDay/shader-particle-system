/*!
* Proton v1.0.7
* https://github.com/JackXie60/shader-particle-system
* Copyright 2022-2025, JackXie60
* Licensed under the MIT license
* http://www.opensource.org/licenses/mit-license
*
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["shader-particle-system"]={},e.THREE)}(this,(function(e,t){"use strict";function r(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var a=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var a=r(t),i={types:{Boolean:"boolean",STRING:"string",NUMBER:"number",OBJECT:"object"},ensureTypedArg:(e,t,r)=>typeof e===t?e:r,ensureArrayTypedArg(e,t,r){if(Array.isArray(e)){for(let a=e.length-1;a>=0;--a)if(typeof e[a]!==t)return r;return e}return this.ensureTypedArg(e,t,r)},ensureInstanceOf:(e,t,r)=>t&&e instanceof t?e:void 0===e||t?r:e,ensureArrayInstanceOf(e,t,r){if(Array.isArray(e)){if(t)for(let a=e.length-1;a>=0;--a)if(e[a]instanceof t==!1)return r;return e}return this.ensureInstanceOf(e,t,r)},ensureValueOverLifetimeCompliance(e,t=3,r=3){t=t||3,r=r||3,!1===Array.isArray(e._value)&&(e._value=[e._value]),!1===Array.isArray(e._spread)&&(e._spread=[e._spread]);const a=this.clamp(e._value.length,t,r),i=this.clamp(e._spread.length,t,r),s=Math.max(a,i);e._value.length!==s&&(e._value=this.interpolateArray(e._value,s)),e._spread.length!==s&&(e._spread=this.interpolateArray(e._spread,s))},interpolateArray(e,t){const r=e.length,a=["object"==typeof e[0]?e[0].clone():e[0]],i=(r-1)/(t-1);for(let r=1;r<t-1;++r){const t=r*i,s=Math.floor(t),o=Math.ceil(t),n=t-s;a[r]=this.lerpTypeAgnostic(e[s],e[o],n)}return a.push("object"==typeof e[r-1]&&e[r-1].clone?e[r-1].clone():e[r-1]),a},clamp:(e,t,r)=>Math.max(t,Math.min(e,r)),zeroToEpsilon(e,t){const r=1e-5;let a=e;return a=t?Math.random()*r*10:r,e<0&&e>-1e-5&&(a=-a),a},lerpTypeAgnostic(e,t,r){const i=this.types;let s;return typeof e===i.NUMBER&&typeof t===i.NUMBER?e+(t-e)*r:e instanceof a.Vector2&&t instanceof a.Vector2?(s=e.clone(),s.x=this.lerp(e.x,t.x,r),s.y=this.lerp(e.y,t.y,r),s):e instanceof a.Vector3&&t instanceof a.Vector3?(s=e.clone(),s.x=this.lerp(e.x,t.x,r),s.y=this.lerp(e.y,t.y,r),s.z=this.lerp(e.z,t.z,r),s):e instanceof a.Vector4&&t instanceof a.Vector4?(s=e.clone(),s.x=this.lerp(e.x,t.x,r),s.y=this.lerp(e.y,t.y,r),s.z=this.lerp(e.z,t.z,r),s.w=this.lerp(e.w,t.w,r),s):e instanceof a.Color&&t instanceof a.Color?(s=e.clone(),s.r=this.lerp(e.r,t.r,r),s.g=this.lerp(e.g,t.g,r),s.b=this.lerp(e.b,t.b,r),s):void console.warn("Invalid argument types, or argument types do not match:",e,t)},lerp:(e,t,r)=>e+(t-e)*r,roundToNearestMultiple(e,t){let r=0;return 0===t?e:(r=Math.abs(e)%t,0===r?e:e<0?-(Math.abs(e)-r):e+t-r)},arrayValuesAreEqual(e){for(let t=0;t<e.length-1;++t)if(e[t]!==e[t+1])return!1;return!0},randomFloat:(e,t)=>e+t*(Math.random()-.5),randomVector3(e,t,r,a,i){let s=r.x+(Math.random()*a.x-.5*a.x),o=r.y+(Math.random()*a.y-.5*a.y),n=r.z+(Math.random()*a.z-.5*a.z);i&&(s=.5*-i.x+this.roundToNearestMultiple(s,i.x),o=.5*-i.y+this.roundToNearestMultiple(o,i.y),n=.5*-i.z+this.roundToNearestMultiple(n,i.z)),e.typedArray.setVec3Components(t,s,o,n)},randomColor(e,t,r,a){let i=r.r+Math.random()*a.x,s=r.g+Math.random()*a.y,o=r.b+Math.random()*a.z;i=this.clamp(i,0,1),s=this.clamp(s,0,1),o=this.clamp(o,0,1),e.typedArray.setVec3Components(t,i,s,o)},randomColorAsHex:function(e){const t=new a.Color;return function(r,a,i,s){const o=i.length,n=[];for(let r=0;r<o;++r){const a=s[r];t.copy(i[r]),t.r+=Math.random()*a.x-.5*a.x,t.g+=Math.random()*a.y-.5*a.y,t.b+=Math.random()*a.z-.5*a.z,t.r=e.clamp(t.r,0,1),t.g=e.clamp(t.g,0,1),t.b=e.clamp(t.b,0,1),n.push(t.getHex())}r.typedArray.setVec4Components(a,n[0]??0,n[1]??0,n[2]??0,n[3]??0)}}(void 0),randomVector3OnLine(e,t,r,a){const i=r.clone();i.lerp(a,Math.random()),e.typedArray.setVec3Components(t,i.x,i.y,i.z)},randomVector3OnSphere(e,t,r,a,i,s,o){const n=2*Math.random()-1,l=6.2832*Math.random(),u=Math.sqrt(1-n*n);let c=this.randomFloat(a,i),p=0,h=0,d=0;o&&(c=Math.round(c/o)*o),p=u*Math.cos(l)*c,h=u*Math.sin(l)*c,d=n*c,p*=s.x,h*=s.y,d*=s.z,p+=r.x,h+=r.y,d+=r.z,e.typedArray.setVec3Components(t,p,h,d)},seededRandom(e){const t=1e4*Math.sin(e);return t-(0|t)},randomVector3OnDisc(e,t,r,a,i,s,o){const n=6.2832*Math.random();let l=Math.abs(this.randomFloat(a,i)),u=0,c=0,p=0;o&&(l=Math.round(l/o)*o),u=Math.cos(n)*l,c=Math.sin(n)*l,u*=s.x,c*=s.y,u+=r.x,c+=r.y,p+=r.z,e.typedArray.setVec3Components(t,u,c,p)},randomDirectionVector3OnSphere:function(e){const t=new a.Vector3;return function(r,a,i,s,o,n,l,u){t.copy(n),t.x-=i,t.y-=s,t.z-=o,t.normalize().multiplyScalar(-e.randomFloat(l,u)),r.typedArray.setVec3Components(a,t.x,t.y,t.z)}}(void 0),randomDirectionVector3OnDisc:function(e){const t=new a.Vector3;return function(r,a,i,s,o,n,l,u){t.copy(n),t.x-=i,t.y-=s,t.z-=o,t.normalize().multiplyScalar(-e.randomFloat(l,u)),r.typedArray.setVec3Components(a,t.x,t.y,0)}}(void 0),getPackedRotationAxis:function(){const e=new a.Vector3,t=new a.Vector3,r=new a.Color,i=new a.Vector3(1,1,1);return function(a,s){return e.copy(a).normalize(),t.copy(s).normalize(),e.x+=.5*-s.x+Math.random()*s.x,e.y+=.5*-s.y+Math.random()*s.y,e.z+=.5*-s.z+Math.random()*s.z,e.normalize().add(i).multiplyScalar(.5),r.setRGB(e.x,e.y,e.z),r.getHex()}}()};const s=.0167,o={BOX:1,SPHERE:2,DISC:3,LINE:4};var n=Object.freeze({__proto__:null,DEFAULT_SYSTEM_DELTA:s,distributions:o,valueOverLifetimeLength:4});class l{componentSize;size;TypedArrayConstructor;array;indexOffset;constructor(e,t,r,a){this.componentSize=r||1,this.size=t||1,this.TypedArrayConstructor=e||Float32Array,this.array=new this.TypedArrayConstructor(this.size*this.componentSize),this.indexOffset=a||0}setSize(e,t){const r=this.array.length;return t||(e*=this.componentSize),e<r?this.shrink(e):e>r?this.grow(e):void console.info("TypedArray is already of size:",e+".","Will not resize.")}shrink(e){return this.array=this.array.subarray(0,e),this.size=e,this}grow(e){const t=new this.TypedArrayConstructor(e);return t.set(this.array),this.array=t,this.size=e,this}splice(e,t){const r=e*this.componentSize,a=t*this.componentSize,i=[],s=this.array.length;for(let e=0;e<s;++e)(e<r||e>a)&&i.push(this.array[e]);return this.setFromArray(0,i),this}setFromArray(e,t){const r=e+t.length;return r>this.array.length?this.grow(r):r<this.array.length&&this.shrink(r),this.array.set(t,this.indexOffset+e),this}setVec2(e,t){return this.setVec2Components(e,t.x,t.y)}setVec2Components(e,t,r){const a=this.array,i=this.indexOffset+e*this.componentSize;return a[i]=t,a[i+1]=r,this}setVec3(e,t){return this.setVec3Components(e,t.x,t.y,t.z)}setVec3Components(e,t,r,a){const i=this.array,s=this.indexOffset+e*this.componentSize;return i[s]=t,i[s+1]=r,i[s+2]=a,this}setVec4(e,t){return this.setVec4Components(e,t.x,t.y,t.z,t.w)}setVec4Components(e,t,r,a,i){const s=this.array,o=this.indexOffset+e*this.componentSize;return s[o]=t,s[o+1]=r,s[o+2]=a,s[o+3]=i,this}setMat3(e,t){return this.setFromArray(this.indexOffset+e*this.componentSize,t.elements)}setMat4(e,t){return this.setFromArray(this.indexOffset+e*this.componentSize,t.elements)}setColor(e,t){return this.setVec3Components(e,t.r,t.g,t.b)}setNumber(e,t){return this.array[this.indexOffset+e*this.componentSize]=t,this}getValueAtIndex(e){return this.array[this.indexOffset+e]}getComponentValueAtIndex(e){return this.array.subarray(this.indexOffset+e*this.componentSize)}}class u{type;componentSize;arrayType;typedArray;bufferAttribute;dynamicBuffer;updateMin;updateMax;static typeSizeMap={f:1,v2:2,v3:3,v4:4,c:3,m3:9,m4:16};constructor(e,t,r){const a=u.typeSizeMap;this.type="string"==typeof e&&Object.prototype.hasOwnProperty.call(a,e)?e:"f",this.componentSize=a[this.type],this.arrayType=r||Float32Array,this.typedArray=null,this.bufferAttribute=null,this.dynamicBuffer=!!t,this.updateMin=0,this.updateMax=0}setUpdateRange(e,t){this.updateMin=Math.min(e*this.componentSize,this.updateMin*this.componentSize),this.updateMax=Math.max(t*this.componentSize,this.updateMax*this.componentSize)}flagUpdate(){const e=this.bufferAttribute;e&&this.typedArray&&(e.clearUpdateRanges(),e.addUpdateRange(this.updateMin,Math.min(this.updateMax-this.updateMin+this.componentSize,this.typedArray.array.length)),e.needsUpdate=!0)}resetUpdateRange(){this.updateMin=0,this.updateMax=0}resetDynamic(){this.bufferAttribute&&(this.bufferAttribute.usage=this.dynamicBuffer?a.DynamicDrawUsage:a.StaticDrawUsage)}splice(e,t){this.typedArray&&(this.typedArray.splice(e,t),this.forceUpdateAll())}forceUpdateAll(){this.bufferAttribute&&this.typedArray&&(this.bufferAttribute.array=this.typedArray.array,this.bufferAttribute.clearUpdateRanges(),this.bufferAttribute.addUpdateRange(0,-1),this.bufferAttribute.usage=a.StaticDrawUsage,this.bufferAttribute.needsUpdate=!0)}_ensureTypedArray(e){null!==this.typedArray&&this.typedArray.size===e*this.componentSize||(null!==this.typedArray&&this.typedArray.size!==e?this.typedArray.setSize(e):null===this.typedArray&&(this.typedArray=new l(this.arrayType,e,this.componentSize)))}_createBufferAttribute(e){if(this._ensureTypedArray(e),null!==this.bufferAttribute)return this.typedArray&&this.bufferAttribute.set(this.typedArray.array),void(this.bufferAttribute.needsUpdate=!0);this.bufferAttribute=new a.BufferAttribute(this.typedArray.array,this.componentSize),this.bufferAttribute.usage=this.dynamicBuffer?a.DynamicDrawUsage:a.StaticDrawUsage}getLength(){return null===this.typedArray?0:this.typedArray.array.length}}var c={defines:["#define PACKED_COLOR_SIZE 256.0","#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),uniforms:["uniform float deltaTime;","uniform float runTime;","uniform sampler2D tex;","uniform vec4 textureAnimation;","uniform float scale;"].join("\n"),attributes:["attribute vec4 acceleration;","attribute vec3 velocity;","attribute vec4 rotation;","attribute vec3 rotationCenter;","attribute vec4 params;","attribute vec4 size;","attribute vec4 angle;","attribute vec4 color;","attribute vec4 opacity;"].join("\n"),varyings:["varying vec4 vColor;","#ifdef SHOULD_ROTATE_TEXTURE","    varying float vAngle;","#endif","#ifdef SHOULD_CALCULATE_SPRITE","    varying vec4 vSpriteSheet;","#endif"].join("\n"),branchAvoidanceFunctions:["float when_gt(float x, float y) {","    return max(sign(x - y), 0.0);","}","float when_lt(float x, float y) {","    return min( max(1.0 - sign(x - y), 0.0), 1.0 );","}","float when_eq( float x, float y ) {","    return 1.0 - abs( sign( x - y ) );","}","float when_ge(float x, float y) {","  return 1.0 - when_lt(x, y);","}","float when_le(float x, float y) {","  return 1.0 - when_gt(x, y);","}","float and(float a, float b) {","    return a * b;","}","float or(float a, float b) {","    return min(a + b, 1.0);","}"].join("\n"),unpackColor:["vec3 unpackColor( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   return c;","}"].join("\n"),unpackRotationAxis:["vec3 unpackRotationAxis( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   c *= vec3( 2.0 );","   c -= vec3( 1.0 );","   return c;","}"].join("\n"),floatOverLifetime:["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {","    highp float value = 0.0;","    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );","    float fIndex = 0.0;","    float shouldApplyValue = 0.0;","    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );","","    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {","       fIndex = float( i );","       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );","       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );","    }","","    return value;","}"].join("\n"),colorOverLifetime:["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {","    vec3 value = vec3( 0.0 );","    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );","    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );","    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );","    return value;","}"].join("\n"),paramFetchingFunctions:["float getAlive() {","   return params.x;","}","float getAge() {","   return params.y;","}","float getMaxAge() {","   return params.z;","}","float getWiggle() {","   return params.w;","}"].join("\n"),forceFetchingFunctions:["vec4 getPosition( in float age ) {","   return modelViewMatrix * vec4( position, 1.0 );","}","vec3 getVelocity( in float age ) {","   return velocity * age;","}","vec3 getAcceleration( in float age ) {","   return acceleration.xyz * age;","}"].join("\n"),rotationFunctions:["#ifdef SHOULD_ROTATE_PARTICLES","   mat4 getRotationMatrix( in vec3 axis, in float angle) {","       axis = normalize(axis);","       float s = sin(angle);","       float c = cos(angle);","       float oc = 1.0 - c;","","       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,","                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,","                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,","                   0.0,                                0.0,                                0.0,                                1.0);","   }","","   vec3 getRotation( in vec3 pos, in float positionInTime ) {","      if( rotation.y == 0.0 ) {","           return pos;","      }","","      vec3 axis = unpackRotationAxis( rotation.x );","      vec3 center = rotationCenter;","      vec3 translated;","      mat4 rotationMatrix;","      float angle = 0.0;","      angle += when_eq( rotation.z, 0.0 ) * rotation.y;","      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );","      translated = rotationCenter - pos;","      rotationMatrix = getRotationMatrix( axis, angle );","      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );","   }","#endif"].join("\n"),rotateTexture:["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );","","    #ifdef SHOULD_ROTATE_TEXTURE","       float x = gl_PointCoord.x - 0.5;","       float y = 1.0 - gl_PointCoord.y - 0.5;","       float c = cos( -vAngle );","       float s = sin( -vAngle );","       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );","    #endif","","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = vSpriteSheet.x;","        float framesY = vSpriteSheet.y;","        float columnNorm = vSpriteSheet.z;","        float rowNorm = vSpriteSheet.w;","        vUv.x = gl_PointCoord.x * framesX + columnNorm;","        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);","    #endif","","    vec4 rotatedTexture = texture2D( tex, vUv );"].join("\n")},p={vertex:[c.defines,c.uniforms,c.attributes,c.varyings,a.ShaderChunk.common,a.ShaderChunk.logdepthbuf_pars_vertex,a.ShaderChunk.fog_pars_fragment,c.branchAvoidanceFunctions,c.unpackColor,c.unpackRotationAxis,c.floatOverLifetime,c.colorOverLifetime,c.paramFetchingFunctions,c.forceFetchingFunctions,c.rotationFunctions,"void main() {","    highp float age = getAge();","    highp float alive = getAlive();","    highp float maxAge = getMaxAge();","    highp float positionInTime = (age / maxAge);","    highp float isAlive = when_gt( alive, 0.0 );","    #ifdef SHOULD_WIGGLE_PARTICLES","        float wiggleAmount = positionInTime * getWiggle();","        float wiggleSin = isAlive * sin( wiggleAmount );","        float wiggleCos = isAlive * cos( wiggleAmount );","    #endif","    vec3 vel = getVelocity( age );","    vec3 accel = getAcceleration( age );","    vec3 force = vec3( 0.0 );","    vec3 pos = vec3( position );","    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;","    force += vel;","    force *= drag;","    force += accel * age;","    pos += force;","    #ifdef SHOULD_WIGGLE_PARTICLES","        pos.x += wiggleSin;","        pos.y += wiggleCos;","        pos.z += wiggleSin;","    #endif","    #ifdef SHOULD_ROTATE_PARTICLES","        pos = getRotation( pos, positionInTime );","    #endif","    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );","    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;","    #ifdef HAS_PERSPECTIVE","        float perspective = scale / length( mvPosition.xyz );","    #else","        float perspective = 1.0;","    #endif","    float pointSizePerspective = pointSize * perspective;","    #ifdef COLORIZE","       vec3 c = isAlive * getColorOverLifetime(","           positionInTime,","           unpackColor( color.x ),","           unpackColor( color.y ),","           unpackColor( color.z ),","           unpackColor( color.w )","       );","    #else","       vec3 c = vec3(1.0);","    #endif","    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );","    vColor = vec4( c, o );","    #ifdef SHOULD_ROTATE_TEXTURE","        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );","    #endif","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = textureAnimation.x;","        float framesY = textureAnimation.y;","        float loopCount = textureAnimation.w;","        float totalFrames = textureAnimation.z;","        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );","        float column = floor(mod( frameNumber, framesX ));","        float row = floor( (frameNumber - column) / framesX );","        float columnNorm = column / framesX;","        float rowNorm = row / framesY;","        vSpriteSheet.x = 1.0 / framesX;","        vSpriteSheet.y = 1.0 / framesY;","        vSpriteSheet.z = columnNorm;","        vSpriteSheet.w = rowNorm;","    #endif","    gl_PointSize = pointSizePerspective;","    gl_Position = projectionMatrix * mvPosition;",a.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragment:[c.uniforms,a.ShaderChunk.common,a.ShaderChunk.fog_pars_fragment,a.ShaderChunk.logdepthbuf_pars_fragment,c.varyings,c.branchAvoidanceFunctions,"void main() {","    vec3 outgoingLight = vColor.xyz;","    ","    #ifdef ALPHATEST","       if ( vColor.w < float(ALPHATEST) ) discard;","    #endif",c.rotateTexture,a.ShaderChunk.logdepthbuf_fragment,"    outgoingLight = vColor.xyz * rotatedTexture.xyz;","    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",a.ShaderChunk.fog_fragment,"}"].join("\n")};class h{uuid;type;position;velocity;acceleration;drag;wiggle;rotation;maxAge;color;opacity;size;angle;particleCount;duration;isStatic;activeMultiplier;direction;alive;particlesPerSecond;activationIndex;attributeOffset;age;activeParticleCount;group;attributes;paramsArray;resetFlags;updateFlags;updateCounts;updateMap;bufferUpdateRanges;attributeKeys;attributeCount;activationEnd;constructor(e){const t=i.types;(e=i.ensureTypedArg(e,t.OBJECT,{})).position=i.ensureTypedArg(e.position,t.OBJECT,{}),e.velocity=i.ensureTypedArg(e.velocity,t.OBJECT,{}),e.acceleration=i.ensureTypedArg(e.acceleration,t.OBJECT,{}),e.radius=i.ensureTypedArg(e.radius,t.OBJECT,{}),e.drag=i.ensureTypedArg(e.drag,t.OBJECT,{}),e.rotation=i.ensureTypedArg(e.rotation,t.OBJECT,{}),e.color=i.ensureTypedArg(e.color,t.OBJECT,{}),e.opacity=i.ensureTypedArg(e.opacity,t.OBJECT,{}),e.size=i.ensureTypedArg(e.size,t.OBJECT,{}),e.angle=i.ensureTypedArg(e.angle,t.OBJECT,{}),e.wiggle=i.ensureTypedArg(e.wiggle,t.OBJECT,{}),e.maxAge=i.ensureTypedArg(e.maxAge,t.OBJECT,{}),e.onParticleSpawn&&console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),this.uuid=a.MathUtils.generateUUID(),this.type=i.ensureTypedArg(e.type,t.NUMBER,o.BOX),this.position={_value:i.ensureInstanceOf(e.position.value,a.Vector3,new a.Vector3),_spread:i.ensureInstanceOf(e.position.spread,a.Vector3,new a.Vector3),_spreadClamp:i.ensureInstanceOf(e.position.spreadClamp,a.Vector3,new a.Vector3),_distribution:i.ensureTypedArg(e.position.distribution,t.NUMBER,this.type),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1),_radius:i.ensureTypedArg(e.position.radius,t.NUMBER,10),_radiusScale:i.ensureInstanceOf(e.position.radiusScale,a.Vector3,new a.Vector3(1,1,1)),_distributionClamp:i.ensureTypedArg(e.position.distributionClamp,t.NUMBER,0)},this.velocity={_value:i.ensureInstanceOf(e.velocity.value,a.Vector3,new a.Vector3),_spread:i.ensureInstanceOf(e.velocity.spread,a.Vector3,new a.Vector3),_distribution:i.ensureTypedArg(e.velocity.distribution,t.NUMBER,this.type),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.acceleration={_value:i.ensureInstanceOf(e.acceleration.value,a.Vector3,new a.Vector3),_spread:i.ensureInstanceOf(e.acceleration.spread,a.Vector3,new a.Vector3),_distribution:i.ensureTypedArg(e.acceleration.distribution,t.NUMBER,this.type),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.drag={_value:i.ensureTypedArg(e.drag.value,t.NUMBER,0),_spread:i.ensureTypedArg(e.drag.spread,t.NUMBER,0),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.wiggle={_value:i.ensureTypedArg(e.wiggle.value,t.NUMBER,0),_spread:i.ensureTypedArg(e.wiggle.spread,t.NUMBER,0)},this.rotation={_axis:i.ensureInstanceOf(e.rotation.axis,a.Vector3,new a.Vector3(0,1,0)),_axisSpread:i.ensureInstanceOf(e.rotation.axisSpread,a.Vector3,new a.Vector3),_angle:i.ensureTypedArg(e.rotation.angle,t.NUMBER,0),_angleSpread:i.ensureTypedArg(e.rotation.angleSpread,t.NUMBER,0),_static:i.ensureTypedArg(e.rotation.static,t.Boolean,!1),_center:i.ensureInstanceOf(e.rotation.center,a.Vector3,this.position._value.clone()),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.maxAge={_value:i.ensureTypedArg(e.maxAge.value,t.NUMBER,2),_spread:i.ensureTypedArg(e.maxAge.spread,t.NUMBER,0)},this.color={_value:i.ensureArrayInstanceOf(e.color.value,a.Color,new a.Color),_spread:i.ensureArrayInstanceOf(e.color.spread,a.Vector3,new a.Vector3),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.opacity={_value:i.ensureArrayTypedArg(e.opacity.value,t.NUMBER,1),_spread:i.ensureArrayTypedArg(e.opacity.spread,t.NUMBER,0),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.size={_value:i.ensureArrayTypedArg(e.size.value,t.NUMBER,1),_spread:i.ensureArrayTypedArg(e.size.spread,t.NUMBER,0),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.angle={_value:i.ensureArrayTypedArg(e.angle.value,t.NUMBER,0),_spread:i.ensureArrayTypedArg(e.angle.spread,t.NUMBER,0),_randomise:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)},this.particleCount=i.ensureTypedArg(e.particleCount,t.NUMBER,100),this.duration=i.ensureTypedArg(e.duration,t.NUMBER,null),this.isStatic=i.ensureTypedArg(e.isStatic,t.Boolean,!1),this.activeMultiplier=i.ensureTypedArg(e.activeMultiplier,t.NUMBER,1),this.direction=i.ensureTypedArg(e.direction,t.NUMBER,1),this.alive=i.ensureTypedArg(e.alive,t.Boolean,!0),this.particlesPerSecond=0,this.activationIndex=0,this.activationEnd=0,this.attributeOffset=0,this.age=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.resetFlags={position:i.ensureTypedArg(e.position.randomise,t.Boolean,!1)||i.ensureTypedArg(e.radius.randomise,t.Boolean,!1),velocity:i.ensureTypedArg(e.velocity.randomise,t.Boolean,!1),acceleration:i.ensureTypedArg(e.acceleration.randomise,t.Boolean,!1)||i.ensureTypedArg(e.drag.randomise,t.Boolean,!1),rotation:i.ensureTypedArg(e.rotation.randomise,t.Boolean,!1),rotationCenter:i.ensureTypedArg(e.rotation.randomise,t.Boolean,!1),size:i.ensureTypedArg(e.size.randomise,t.Boolean,!1),color:i.ensureTypedArg(e.color.randomise,t.Boolean,!1),opacity:i.ensureTypedArg(e.opacity.randomise,t.Boolean,!1),angle:i.ensureTypedArg(e.angle.randomise,t.Boolean,!1)},this.updateFlags={},this.updateCounts={},this.updateMap={maxAge:"params",position:"position",velocity:"velocity",acceleration:"acceleration",drag:"acceleration",wiggle:"params",rotation:"rotation",size:"size",color:"color",opacity:"opacity",angle:"angle"};for(const e in this.updateMap)if(this.updateMap.hasOwnProperty(e)){this.updateCounts[this.updateMap[e]]=0,this.updateFlags[this.updateMap[e]]=!1;const t=this[e];if(null===t||"object"!=typeof t)continue;this._createGetterSetters(t,e)}this.bufferUpdateRanges={},this.attributeKeys=null,this.attributeCount=0,i.ensureValueOverLifetimeCompliance(this.color,4,4),i.ensureValueOverLifetimeCompliance(this.opacity,4,4),i.ensureValueOverLifetimeCompliance(this.size,4,4),i.ensureValueOverLifetimeCompliance(this.angle,4,4)}_createGetterSetters(e,t){const r=this;Object.keys(e).forEach((a=>{const s=a.replace("_","");Object.defineProperty(e,s,{get(){return this[a]},set(e){const s=r.updateMap[t],o=this[a];"_rotationCenter"===a?(r.updateFlags.rotationCenter=!0,r.updateCounts.rotationCenter=0):"_randomise"===a?r.resetFlags[s]=!!e:(r.updateFlags[s]=!0,r.updateCounts[s]=0),r.group&&r.group._updateDefines(),this[a]=e,Array.isArray(o)&&i.ensureValueOverLifetimeCompliance(r[t],4,4)}})}))}_setBufferUpdateRanges(e){this.attributeKeys=e,this.attributeCount=e.length;for(let t=this.attributeCount-1;t>=0;--t)this.bufferUpdateRanges[e[t]]={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}_calculatePPSValue(e){const t=this.particleCount;this.duration?this.particlesPerSecond=t/(e<this.duration?e:this.duration):this.particlesPerSecond=t/e}_setAttributeOffset(e){this.attributeOffset=e,this.activationIndex=e,this.activationEnd=e+this.particleCount}_assignValue(e,t){switch(e){case"position":this._assignPositionValue(t);break;case"velocity":case"acceleration":this._assignForceValue(t,e);break;case"size":case"opacity":this._assignAbsLifetimeValue(t,e);break;case"angle":this._assignAngleValue(t);break;case"params":this._assignParamsValue(t);break;case"rotation":this._assignRotationValue(t);break;case"color":this._assignColorValue(t)}}_assignPositionValue(e){if(!this.attributes)return;const t=this.position,r=this.attributes.position,a=t._value,s=t._spread;switch(t._distribution){case o.BOX:i.randomVector3(r,e,a,s,t._spreadClamp);break;case o.SPHERE:i.randomVector3OnSphere(r,e,a,t._radius,t._spread.x,t._radiusScale,t._spreadClamp.x);break;case o.DISC:i.randomVector3OnDisc(r,e,a,t._radius,t._spread.x,t._radiusScale,t._spreadClamp.x);break;case o.LINE:i.randomVector3OnLine(r,e,a,s)}}_assignForceValue(e,t){if(!this.attributes)return;const r=this[t],a=r._value,s=r._spread;let n,l,u,c,p;switch(r._distribution){case o.BOX:i.randomVector3(this.attributes[t],e,a,s);break;case o.SPHERE:n=this.attributes.position.typedArray.array,p=3*e,l=n[p],u=n[p+1],c=n[p+2],i.randomDirectionVector3OnSphere(this.attributes[t],e,l,u,c,this.position._value,r._value.x,r._spread.x);break;case o.DISC:n=this.attributes.position.typedArray.array,p=3*e,l=n[p],u=n[p+1],c=n[p+2],i.randomDirectionVector3OnDisc(this.attributes[t],e,l,u,c,this.position._value,r._value.x,r._spread.x);break;case o.LINE:i.randomVector3OnLine(this.attributes[t],e,a,s)}if("acceleration"===t){const t=i.clamp(i.randomFloat(this.drag._value,this.drag._spread),0,1);this.attributes.acceleration.typedArray.array[4*e+3]=t}}_assignAbsLifetimeValue(e,t){if(!this.attributes)return;const r=this.attributes[t].typedArray,a=this[t];let s;if(Array.isArray(a._value)&&Array.isArray(a._spread)&&i.arrayValuesAreEqual(a._value)&&i.arrayValuesAreEqual(a._spread))s=Math.abs(i.randomFloat(a._value[0],a._spread[0])),r.setVec4Components(e,s,s,s,s);else{const t=Array.isArray(a._value)?a._value[0]:a._value,s=Array.isArray(a._value)?a._value[1]:a._value,o=Array.isArray(a._value)?a._value[2]:a._value,n=Array.isArray(a._value)?a._value[3]:a._value,l=Array.isArray(a._spread)?a._spread[0]:a._spread,u=Array.isArray(a._spread)?a._spread[1]:a._spread,c=Array.isArray(a._spread)?a._spread[2]:a._spread,p=Array.isArray(a._spread)?a._spread[3]:a._spread;r.setVec4Components(e,Math.abs(i.randomFloat(t,l)),Math.abs(i.randomFloat(s,u)),Math.abs(i.randomFloat(o,c)),Math.abs(i.randomFloat(n,p)))}}_assignAngleValue(e){if(!this.attributes)return;const t=this.attributes.angle.typedArray,r=this.angle;let a;if(Array.isArray(r._value)&&Array.isArray(r._spread)&&i.arrayValuesAreEqual(r._value)&&i.arrayValuesAreEqual(r._spread))a=i.randomFloat(r._value[0],r._spread[0]),t.setVec4Components(e,a,a,a,a);else{const a=Array.isArray(r._value)?r._value[0]:r._value,s=Array.isArray(r._value)?r._value[1]:r._value,o=Array.isArray(r._value)?r._value[2]:r._value,n=Array.isArray(r._value)?r._value[3]:r._value,l=Array.isArray(r._spread)?r._spread[0]:r._spread,u=Array.isArray(r._spread)?r._spread[1]:r._spread,c=Array.isArray(r._spread)?r._spread[2]:r._spread,p=Array.isArray(r._spread)?r._spread[3]:r._spread;t.setVec4Components(e,i.randomFloat(a,l),i.randomFloat(s,u),i.randomFloat(o,c),i.randomFloat(n,p))}}_assignParamsValue(e){this.attributes&&this.attributes.params.typedArray.setVec4Components(e,this.isStatic?1:0,0,Math.abs(i.randomFloat(this.maxAge._value,this.maxAge._spread)),i.randomFloat(this.wiggle._value,this.wiggle._spread))}_assignRotationValue(e){this.attributes&&(this.attributes.rotation.typedArray.setVec3Components(e,i.getPackedRotationAxis(this.rotation._axis,this.rotation._axisSpread),i.randomFloat(this.rotation._angle,this.rotation._angleSpread),this.rotation._static?0:1),this.attributes.rotationCenter.typedArray.setVec3(e,this.rotation._center))}_assignColorValue(e){this.attributes&&Array.isArray(this.color._value)&&Array.isArray(this.color._spread)&&i.randomColorAsHex(this.attributes.color,e,this.color._value,this.color._spread)}_resetParticle(e){const t=this.resetFlags,r=this.updateFlags,a=this.updateCounts,i=this.attributeKeys;let s,o;if(i)for(let n=this.attributeCount-1;n>=0;--n)s=i[n],o=r[s],!0!==t[s]&&!0!==o||(this._assignValue(s,e),this._updateAttributeUpdateRange(s,e),!0===o&&a[s]===this.particleCount?(r[s]=!1,a[s]=0):!0===o&&++a[s])}_updateAttributeUpdateRange(e,t){const r=this.bufferUpdateRanges[e];r.min=Math.min(t,r.min),r.max=Math.max(t,r.max)}_resetBufferRanges(){const e=this.bufferUpdateRanges,t=this.attributeKeys;if(t)for(let r=t.length-1;r>=0;--r){const a=t[r];e[a].min=Number.POSITIVE_INFINITY,e[a].max=Number.NEGATIVE_INFINITY}}_onRemove(){this.particlesPerSecond=0,this.attributeOffset=0,this.activationIndex=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.age=0}_decrementParticleCount(){--this.activeParticleCount}_incrementParticleCount(){++this.activeParticleCount}_checkParticleAges(e,t,r,a){for(let i,s,o,n,l=t-1;l>=e;--l)i=4*l,n=r[i],0!==n&&(o=r[i+1],s=r[i+2],1===this.direction?(o+=a,o>=s&&(o=0,n=0,this._decrementParticleCount())):(o-=a,o<=0&&(o=s,n=0,this._decrementParticleCount())),r[i]=n,r[i+1]=o,this._updateAttributeUpdateRange("params",l))}_activateParticles(e,t,r,a){const i=this.direction;for(let s,o,n=e;n<t;++n)s=4*n,0!==r[s]&&1!==this.particleCount||(this._incrementParticleCount(),r[s]=1,this._resetParticle(n),o=a*(n-e),r[s+1]=-1===i?r[s+2]-o:o,this._updateAttributeUpdateRange("params",n))}update(e){if(this.isStatic)return;null===this.paramsArray&&this.attributes&&(this.paramsArray=this.attributes.params.typedArray.array);const t=this.attributeOffset,r=t+this.particleCount,a=this.paramsArray,i=this.particlesPerSecond*this.activeMultiplier*e,s=this.activationIndex;if(this._resetBufferRanges(),this._checkParticleAges(t,r,a,e),!1===this.alive)return void(this.age=0);if(null!==this.duration&&this.age>this.duration)return this.alive=!1,void(this.age=0);const o=1===this.particleCount?s:0|s,n=Math.min(o+i,this.activationEnd),l=n-this.activationIndex|0,u=l>0?e/l:0;this._activateParticles(o,n,a,u),this.activationIndex+=i,this.activationIndex>r&&(this.activationIndex=t),this.age+=e}reset(e){if(this.age=0,this.alive=!1,!0===e){const e=this.attributeOffset,t=e+this.particleCount,r=this.paramsArray;if(!this.attributes)return;const a=this.attributes.params.bufferAttribute;for(let a,i=t-1;i>=e;--i){if(a=4*i,!r)return;r[a]=0,r[a+1]=0}a.updateRange.offset=0,a.updateRange.count=-1,a.needsUpdate=!0}return this}enable(){return this.alive=!0,this}disable(){return this.alive=!1,this}remove(){return null!==this.group?this.group.removeEmitter(this):console.error("Emitter does not belong to a group, cannot remove."),this}}class d{uuid;fixedTimeStep;texture;textureFrames;textureFrameCount;textureLoop;hasPerspective;colorize;maxParticleCount;blending;transparent;alphaTest;depthWrite;depthTest;fog;scale;emitters;emitterIDs;_pool;_poolCreationSettings;_createNewWhenPoolEmpty;_attributesNeedRefresh;_attributesNeedDynamicReset;particleCount;uniforms;defines;attributes;attributeKeys;attributeCount;material;geometry;mesh;constructor(e){const t=i.types;(e=i.ensureTypedArg(e,t.OBJECT,{})).texture=i.ensureTypedArg(e.texture,t.OBJECT,{}),this.uuid=a.MathUtils.generateUUID(),this.fixedTimeStep=i.ensureTypedArg(e.fixedTimeStep,t.NUMBER,s),this.texture=e.texture.value||null,this.textureFrames=e.texture.frames||new a.Vector2(1,1),this.textureFrameCount=i.ensureTypedArg(e.texture.frameCount,t.NUMBER,this.textureFrames.x*this.textureFrames.y),this.textureLoop=i.ensureTypedArg(e.texture.loop,t.NUMBER,1),this.textureFrames.max(new a.Vector2(1,1)),this.hasPerspective=i.ensureTypedArg(e.hasPerspective,t.Boolean,!0),this.colorize=i.ensureTypedArg(e.colorize,t.Boolean,!0),this.maxParticleCount=i.ensureTypedArg(e.maxParticleCount,t.NUMBER,null),this.blending=i.ensureTypedArg(e.blending,t.NUMBER,a.AdditiveBlending),this.transparent=i.ensureTypedArg(e.transparent,t.Boolean,!0),this.alphaTest=i.ensureTypedArg(e.alphaTest,t.NUMBER,0),this.depthWrite=i.ensureTypedArg(e.depthWrite,t.Boolean,!1),this.depthTest=i.ensureTypedArg(e.depthTest,t.Boolean,!0),this.fog=i.ensureTypedArg(e.fog,t.Boolean,!0),this.scale=i.ensureTypedArg(e.scale,t.NUMBER,300),this.emitters=[],this.emitterIDs=[],this._pool=[],this._poolCreationSettings=null,this._createNewWhenPoolEmpty=0,this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!1,this.particleCount=0,this.uniforms={tex:{type:"t",value:this.texture},textureAnimation:{type:"v4",value:new a.Vector4(this.textureFrames.x,this.textureFrames.y,this.textureFrameCount,Math.max(Math.abs(this.textureLoop),1))},fogColor:{type:"c",value:this.fog?new a.Color:null},fogNear:{type:"f",value:10},fogFar:{type:"f",value:200},fogDensity:{type:"f",value:.5},deltaTime:{type:"f",value:0},runTime:{type:"f",value:0},scale:{type:"f",value:this.scale}},this.defines={HAS_PERSPECTIVE:this.hasPerspective,COLORIZE:this.colorize,VALUE_OVER_LIFETIME_LENGTH:4,SHOULD_ROTATE_TEXTURE:!1,SHOULD_ROTATE_PARTICLES:!1,SHOULD_WIGGLE_PARTICLES:!1,SHOULD_CALCULATE_SPRITE:this.textureFrames.x>1||this.textureFrames.y>1},this.attributes={position:new u("v3",!0),acceleration:new u("v4",!0),velocity:new u("v3",!0),rotation:new u("v4",!0),rotationCenter:new u("v3",!0),params:new u("v4",!0),size:new u("v4",!0),angle:new u("v4",!0),color:new u("v4",!0),opacity:new u("v4",!0)},this.attributeKeys=Object.keys(this.attributes),this.attributeCount=this.attributeKeys.length,this.material=new a.ShaderMaterial({uniforms:this.uniforms,vertexShader:p.vertex,fragmentShader:p.fragment,blending:this.blending,transparent:this.transparent,alphaTest:this.alphaTest,depthWrite:this.depthWrite,depthTest:this.depthTest,defines:this.defines,fog:this.fog}),this.geometry=new a.BufferGeometry,this.mesh=new a.Points(this.geometry,this.material),null===this.maxParticleCount&&console.warn("Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")}_updateDefines(){const e=this.emitters;let t;const r=this.defines;for(let a=e.length-1;a>=0;--a)t=e[a],!r.SHOULD_CALCULATE_SPRITE&&Array.isArray(t.angle._value)&&Array.isArray(t.angle._spread)&&(r.SHOULD_ROTATE_TEXTURE=r.SHOULD_ROTATE_TEXTURE||!!Math.max(Math.max.apply(null,t.angle._value),Math.max.apply(null,t.angle._spread))),r.SHOULD_ROTATE_PARTICLES=r.SHOULD_ROTATE_PARTICLES||!!Math.max(t.rotation._angle,t.rotation._angleSpread),r.SHOULD_WIGGLE_PARTICLES=r.SHOULD_WIGGLE_PARTICLES||!!Math.max(t.wiggle._value,t.wiggle._spread);this.material.needsUpdate=!0}_applyAttributesToGeometry(){const e=this.attributes,t=this.geometry,r=t.attributes;let a,i;Object.keys(e).forEach((s=>{a=e[s],i=r[s],i?i.array=a.typedArray.array:a.bufferAttribute&&t.setAttribute(s,a.bufferAttribute),a.bufferAttribute&&(a.bufferAttribute.needsUpdate=!0)})),this.geometry.setDrawRange(0,this.particleCount)}addEmitter(e){if(e instanceof h==!1)return void console.error("`emitter` argument must be instance of Emitter. Was provided with:",e);if(this.emitterIDs.indexOf(e.uuid)>-1)return void console.error("Emitter already exists in this group. Will not add again.");if(null!==e.group)return void console.error("Emitter already belongs to another group. Will not add to requested group.");const t=this.attributes,r=this.particleCount,a=r+e.particleCount;this.particleCount=a,null!==this.maxParticleCount&&this.particleCount>this.maxParticleCount&&console.warn("Group: maxParticleCount exceeded. Requesting",this.particleCount,"particles, can support only",this.maxParticleCount),e._calculatePPSValue(e.maxAge._value+e.maxAge._spread),e._setBufferUpdateRanges(this.attributeKeys),e._setAttributeOffset(r),e.group=this,e.attributes=this.attributes;for(const e in t)t.hasOwnProperty(e)&&t[e]._createBufferAttribute(null!==this.maxParticleCount?this.maxParticleCount:this.particleCount);for(let t=r;t<a;++t)e._assignPositionValue(t),e._assignForceValue(t,"velocity"),e._assignForceValue(t,"acceleration"),e._assignAbsLifetimeValue(t,"opacity"),e._assignAbsLifetimeValue(t,"size"),e._assignAngleValue(t),e._assignRotationValue(t),e._assignParamsValue(t),e._assignColorValue(t);return this._applyAttributesToGeometry(),this.emitters.push(e),this.emitterIDs.push(e.uuid),this._updateDefines(),this.material.needsUpdate=!0,this._attributesNeedRefresh=!0,this}removeEmitter(e){const t=this.emitterIDs.indexOf(e.uuid);if(e instanceof h==!1)return void console.error("`emitter` argument must be instance of Emitter. Was provided with:",e);if(-1===t)return void console.error("Emitter does not exist in this group. Will not remove.");const r=e.attributeOffset,a=r+e.particleCount,i=this.attributes.params.typedArray;for(let e=r;e<a;++e)i&&(i.array[4*e]=0,i.array[4*e+1]=0);this.emitters.splice(t,1),this.emitterIDs.splice(t,1);for(const e in this.attributes)this.attributes.hasOwnProperty(e)&&this.attributes[e].splice(r,a);this.particleCount-=e.particleCount,e._onRemove(),this._attributesNeedRefresh=!0}getFromPool(){const e=this._pool,t=this._createNewWhenPoolEmpty;if(e.length)return e.pop();if(t){if(Array.isArray(this._poolCreationSettings))return console.error("Group: Cannot create new emitter from pool when pool was initialized with an array of options."),null;const e=new h(this._poolCreationSettings);return this.addEmitter(e),e}return null}releaseIntoPool(e){if(e instanceof h!=!1)return e.reset(),this._pool.unshift(e),this;console.error("Argument is not instanceof Emitter:",e)}getPool(){return this._pool}addPool(e,t,r){let a;this._poolCreationSettings=t,this._createNewWhenPoolEmpty=r?1:0;for(let r=0;r<e;++r)a=Array.isArray(t)?new h(t[r]):new h(t),this.addEmitter(a),this.releaseIntoPool(a);return this}_triggerSingleEmitter(e){const t=this.getFromPool();if(null!==t)return t&&(e instanceof a.Vector3&&(t.position._value.copy(e),t.position._value=t.position._value),t.enable(),setTimeout((()=>{t.disable(),this.releaseIntoPool(t)}),1e3*Math.max(t.duration??0,t.maxAge._value+t.maxAge._spread))),this;console.log("Group pool ran out.")}triggerPoolEmitter(e,t){if("number"==typeof e&&e>1)for(let r=0;r<e;++r)this._triggerSingleEmitter(t);else this._triggerSingleEmitter(t);return this}_updateUniforms(e){this.uniforms.runTime.value+=e,this.uniforms.deltaTime.value=e}_resetBufferRanges(){const e=this.attributeKeys,t=this.attributes;let r=this.attributeCount-1;for(;r>=0;--r)t[e[r]].resetUpdateRange()}_updateBuffers(e){const t=this.attributeKeys,r=this.attributes,a=e.bufferUpdateRanges;let i,s,o,n=this.attributeCount-1;for(;n>=0;--n)i=t[n],s=a[i],o=r[i],o.setUpdateRange(s.min,s.max),o.flagUpdate()}update(e){const t=this.emitters,r=t.length,a=e||this.fixedTimeStep,i=this.attributeKeys,s=this.attributes;let o;if(this._updateUniforms(a),this._resetBufferRanges(),0!==r||!1!==this._attributesNeedRefresh||!1!==this._attributesNeedDynamicReset){for(let e,i=0;i<r;++i)e=t[i],e.update(a),this._updateBuffers(e);if(!0===this._attributesNeedDynamicReset){for(o=this.attributeCount-1;o>=0;--o)s[i[o]].resetDynamic();this._attributesNeedDynamicReset=!1}if(!0===this._attributesNeedRefresh){for(o=this.attributeCount-1;o>=0;--o)s[i[o]].forceUpdateAll();this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!0}}}dispose(){return this.geometry.dispose(),this.material.dispose(),this}}const f={Group:d,Emitter:h,utils:i,Constants:n,distributions:o};e.Constants=n,e.Emitter=h,e.Group=d,e.SPE=f,e.default=f,e.distributions=o,e.utils=i,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=shader-particle-system.min.js.map
